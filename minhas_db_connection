from __future__ import division
import MySQLdb
import sys
import re
import random
import time
import binascii
from bisect import bisect_right
from heapq import heappop, heappush
import csv

def createCodeIdCodePathDictionary():
    with open(r"results-20190124-124325.csv") as csv_file:
        codeIdCodePath = {}
        csv_reader = csv.reader(csv_file,delimiter = "," )
        count = 0
        for row in csv_reader:
            if count == 0:
                count +=1
            else:
                temp = []
                temp.append(row[5])
                temp.append(row[7])
                codeIdCodePath[row[0]] = temp
    print("dict")
    print(codeIdCodePath)
    return codeIdCodePath

numHashes = 10;
numDocs = 36
dataFile = "preprocessed_data.txt"
plagiaries = {}
print("Shingling articles...")
curShingleID = 0
docsAsShingleSets = {};
numDocs = 36
f = open(dataFile, "r")
docNames = []
t0 = time.time()
totalShingles = 0
for i in range(0, numDocs):
    words = f.readline().split()
    docID = words[0]
    docNames.append(docID)
    del words[0]
    shinglesInDoc = set()
    for index in range(0, len(words) - 2):
        shingle = words[index] + " " + words[index + 1] + " " + words[index + 2]
        crc = binascii.crc32(shingle) & 0xffffffff
        shinglesInDoc.add(crc)
    docsAsShingleSets[docID] = shinglesInDoc
    totalShingles = totalShingles + (len(words) - 2)

f.close()
print('\nShingling ' + str(numDocs) + ' docs took %.2f sec.' % (time.time() - t0))
print('\nAverage shingles per doc: %.2f' % (totalShingles / numDocs))
numElems = int(numDocs * (numDocs - 1) / 2)
JSim = [0 for x in range(numElems)]
estJSim = [0 for x in range(numElems)]
def getTriangleIndex(i, j):
    if i == j:
        sys.stderr.write("Can't access triangle matrix with i == j")
        sys.exit(1)
    # If j < i just swap the values.
    if j < i:
        temp = i
        i = j
        j = temp

    # Calculate the index within the triangular array.
    # This fancy indexing scheme is taken from pg. 211 of:
    # http://infolab.stanford.edu/~ullman/mmds/ch6.pdf
    # But I adapted it for a 0-based index.
    # Note: The division by two should not truncate, it
    #       needs to be a float.
    k = int(i * (numDocs - (i + 1) / 2.0) + j - i) - 1

print('\nGenerating random hash functions...')
maxShingleID = 2 ** 32 - 1
nextPrime = 4294967311
def pickRandomCoeffs(k):
    randList = []

    while k > 0:
        randIndex = random.randint(0, maxShingleID)

        # Ensure that each random number is unique.
        while randIndex in randList:
            randIndex = random.randint(0, maxShingleID)

            # Add the random number to the list.
        randList.append(randIndex)
        k = k - 1

    return randList


# For each of the 'numHashes' hash functions, generate a different coefficient 'a' and 'b'.
coeffA = pickRandomCoeffs(numHashes)
coeffB = pickRandomCoeffs(numHashes)
allCoeff = coeffA + coeffB
print('\nGenerating MinHash signatures for all documents...')
codeIdPath = createCodeIdCodePathDictionary()
# List of documents represented as signature vectors
signatures = []
#docIdList = []

for docID in docNames:
   # docIdList.append(docID)
    temp  = codeIdPath.get(docID)
    repoName = temp[0]
    repoPath = temp[1]
    # Get the shingle set for this document.
    shingleIDSet = docsAsShingleSets[docID]

    # The resulting minhash signature for this document.
    signature = []
    signature.append(docID)
    signature.append(repoName)
    signature.append(repoPath)
    # For each of the random hash functions...
    for i in range(0, numHashes):
        minHashCode = nextPrime + 1
        for shingleID in shingleIDSet:
            hashCode = (coeffA[i] * shingleID + coeffB[i]) % nextPrime
            if hashCode < minHashCode:
                minHashCode = hashCode
        signature.append(minHashCode)
    signatures.append(signature)
elapsed = (time.time() - t0)
print("\nGenerating MinHash signatures took %.2fsec" % elapsed)
print("signatures")
print(signatures)
db = MySQLdb.connect(host = "localhost", user = "kanthi_db", 
cur = db.cursor()
cur.execute("show tables")
for row in cur.fetchall():
   print row[0]

for item in signatures:
		sql = "insert into hash_signatures (code_id,repo_name, code_path,signature1,signature2, signature3, signature4, signature5,signature6,signature7,signature8, signature9,signature10) values(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
		val = (item[0], item[1], item[2], item[3], item[4], item[5],item[6], item[7], item[8], item[9], item[10], item[11], item[12])
		cur.execute(sql,val)
for i in range(0, 10):
		sql = "insert into randomly_generated_values(hashid, value_a, value_b) values (%s,%s,%s)"
		val = (i+1, allCoeff[i], allCoeff[i+10])
		cur.execute(sql,val)
db.commit()

db.close()
